1. Швецов Николай Сергеевич
2. 31 год
3. Уфа, планируем переезжать в г.Королев Московской области
4. Онлайн-курсы Skillbox по специальности PHP-программирование, саморазвитие, читаю книгу PHP 7. Занимаюсь созданием сайтов
на CMS Drupal 7, иногда при этом практикуюсь в PHP
5. PHP немного, JavaScript(библиотека JQuery), немного MySQL
6. Немного ниже среднего, в данный момент только процедурный подход знаю более-менее, ООП недавно начал изучать
7. swede198@yandex.ru
8. 89093491159
9. Стажироваться у вас хочу полный день.
10. Во время обучения в Skillbox увидел, что есть стажировка

Ответы:

1. В)!===
Обоснование. Тройное равенство обозначает полное равенство, восклицательный знак перед оператором означает отрицание.
Отрицание полного равенства записывается !==, то есть с восклицательным знаком и двумя знаками равно. С восклицательным
знаком и тремя знаками равно не существует оператора. Остальные операторы из перечисленных тоже существуют.

2. Г) Переменная $х = 5
Обоснование. Строка заключенная в одинарные ковычки выводится так, как написано, то есть переменные не обрабатываются

3. Б) 12345end
Обоснование. В данном случае конструкция foreach перебирает все элементы массива и выводит их в одну строку. После завершения
выводится еще и строка "end"

4. Конструкция switch-case ищет выполнение условия и в данном случае находит его на шаге "case: 2". На этом конструкция
и закончила бы свою работу, если бы после "case: 2" стоял оператор break. Но его нет и конструкция перечисляет все остальные
кейсы после выполнения условия.

5. В) true
Обоснование. Число 0 в PHP равно null, если используется двойное равно, если же использовать ===, то это сравнение
выдаст false

6. Г) 13
Обоснование. Конструкция for() в данном случае переберет от 0 до 4, число 5 не войдет. Из этого диапозона только 1 и 3
делятся на 2 с остатком. Именно они и выведутся.

7. А) key1...key2...
Обоснование. Конструкция foreach в данном случае перечисляет значения всех элементов ассоциативного массива. То есть
"value1" и "value2". Внутри конструкции мы видим условие что приведенное к числу значение равно нулю. А так и есть в обоих
случаях потому что (int) приведет оба значения к нулю. У данных строк нет чисел в самом начале. если бы было "1value" и
"2value" например, то условие бы не выполнилось.

8. Г) header("Location: http://google.ru")
Обоснование. Сделать редирект на PHP можно с помощью заголовков Location и Refresh

9. В) 05
Обоснование. Параметр функции по умолчанию - 0. Если вызывать функцию без параметра, то он будет по умолчанию и выведет
0, второй вызов функции уже выведет 5. Итого 05

10. В) $a = 'строка';
Обоснование. Переменной можно присвоить значение только с помощью одиночного знака равенства. Переменные в PHP всегда
начинаются со знака доллара. Строки в PHP необходимо брать либо в двойные либо одинарные ковычки. Из всех перечисленных
вариантов только этот вариант соответствует требованиям

11. А) array_unshift()
Обоснование. Только две из перечисленных функций добавляют элементы в массив - array_unshift и array_push. Только
последняя добавляет элементы в конец массива. Вот array_unshift - как раз добавляет элементы в начало массива.

12. Б) 7
Обоснование. Делаем все операции по порядку.  Инкремент перед числом сначала увеличивает на единицу, потом возвращает.
Инкремент после числа сначала возвращает потом прибавляет

getValue1(getValue2(getValue2(getValue1(getValue1(5)))))

getValue1(5) = 5
getValue1(5) = 5
getValue2(5) = 6
getValue2(6) = 7
getValue1(7) = 7

13, Е) bool(false)
Обоснование. Функция in_array в данном случае ищет значение 'test' в массиве [1,2]. Соответственно не находит его и выводит
false. А так как вывод осуществляется с помощью функции var_dump, которая сначала выводит тип переменной, то вывод будет именно таким
так как false имеет булев тип.

14. Вариант 1, вариант 2, вариант 3, вариант 4

Обоснование.

Вариант 1. Substr выводит подстроку длинной 3 символа, первый символ подстроки имеет позицию 3, подсчет идет с нуля и
поэтому первый символ - 1. Итого получается '123';

Вариант 2.Substr выводит подстроку строки '321123' начиная с 3 символа с конца, так как 3 с минусом стоит;

Вариант 3. Сначала str_replace ищет подстроку '123' в строке, заменяет ее на ''. Остается 321. Ну а strrev
переворачивает строку и получается '123';

Вариант 4. Выводятся символы по позиции в строке. Нумерация с нуля начинается и поэтому вывод будет '123'.

15. Д) Ошибка выполнения
Обоснование. На мой взгляд на элементе с ключем 'name' конструкция foreach выдаст ошибку, так как у цикл не найдет
$item['sort']

16.
<?php

$authors = [
                 1 => [
                    'name' => 'Александр Сергеевич',
                    'born' => '1799',
                    'email' => 'arap@pushkin.ru',
                    'books' => [
                        [
                            'title' => 'Лукоморье',
                            'creat' => '1829'
                        ],
                        [
                            'title' => 'Царь Салтан',
                            'creat' => '1832'
                        ]
                    ]
                ],
                2 => [
                    'name' => 'Лев Николаевич',
                    'born' => '1828',
                    'email' => 'lev@tolstoi.ru',
                    'books' => [
                        [
                            'title' => 'Детство',
                            'creat' => '1852'
                        ],
                        [
                            'title' => 'Война и мир',
                            'creat' => '1863'
                        ]
                    ]
                ],
                3 => [
                    'name' => 'Николай Васильевич',
                    'born' => '1809',
                    'email' => 'gogol@mogol.ru',
                    'books' => [
                        [
                            'title' => 'Вий',
                            'creat' => '1835'
                        ]
                    ]
                ]
        ];

foreach ($authors as $author) {
    echo $author['name'] . " - " . $author['email'] . " - " . $author['born'] . "<br />";
}

echo "<br /><hr /><br />";

foreach ($authors as $author) {
    foreach ($author['books'] as $book) {
        echo $book['title'] . " - " . $author['name'] . " - " . $book['creat'] . "<br />";
    }
}


